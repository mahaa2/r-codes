## theta.current is the vector of initial values
## SS is the length of the chain
## burn is the length of the burn-in
## epsilon is the discretization step 
## LF is the number of leapfrog stesp
## y is the data

 hmc <- function(theta.current, SS, burn, epsilon, LF, y)  {

	ratio = 0

  ## preallocate matrix for the chain
	theta      <- matrix( , SS, 3)
	theta[1, ] <- theta.current  

  start.time <- Sys.time()

	## generating chain
	for(i in 2:SS) {
	
	   pn     <- rnorm(3, 0 ,1) ## mvrnorm(1, rep(0, 3), G)
	   thetan <- theta[i-1, ]

	   ## current Hamiltonian
     H.current <- - ll(thetan, y) + t(pn)%*%pn/2 ## invG

	   ## standard leapfrog steps
	   pn <- pn + epsilon/2 * nll(thetan, y)
	   for (l in 1:LF) {
 	       thetan <- thetan + epsilon * pn  ## invG
	       if (l != LF)  pn <- pn + epsilon * nll(thetan, y)
	   }
	   pn <- pn + epsilon/2 * nll(thetan, y)
           pn <- -pn

           ## proposed Hamiltonian and log-ratio Hamiltonian
	   H.prop <- - ll(thetan, y) + t(pn)%*%pn/2 ## invG
	   logratio <- - log(H.prop) + log(H.current)
 
           ## applying metropolis rule
	   if ( (logratio > 0 | logratio > log(runif(1))) & logratio != "NaN" ) {
	   theta[i, ] <- thetan
	   ratio  <- ratio + 1
	   }
	   else theta[i, ] <- theta[i-1, ]

	}

      print(Sys.time()-start.time)
      theta[ ,2]      = exp(theta[ ,2])
      theta           = theta[(burn + 1):SS, ]
 return(list(theta = theta, r = ratio/SS))
 }
